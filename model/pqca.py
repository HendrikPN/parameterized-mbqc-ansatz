import tensorflow as tf
import tensorflow_quantum as tfq
import cirq, sympy, scipy
import numpy as np
import pickle

class PQCAModel():
    """
    Praramterized MBQC Ansatz based on Clifford Quantum Cellular Automaton 
    (CQCA) as tensorflow quantum model.

    This model contains the full circuit generated by `PQCACirc` and the 
    tf model generated by `PQCALayer`.

    TODO: Distinguish supervised and generative learning by the `step`
    and allow no encoding circuit in tf Layer classes.

    Args:
        qubits (cirq.Qubit): The logical qubits.
        num_layers_enc (int): The number of encoding layers.
        num_layers_var(int); The number of variational layers.
        cqca (list of list): List of list of strings of 'CZx', 'H', 'S', 
                                which make up the translationally invariant 
                                cqcas, where x is the distance of the CZ.
        observables (list of cirq.ops): The measured observables.
        train (bool): Whether the tfq layer is trainable or not.
        single_param (bool): Whether or not there is only one variational param
                             per layer. Default: False
        lr_var (float): Learning rate for variational circuit. Default: 0.01
        lr_out (float): Learning rate for output rescaling layer. Default: 0.1
    """
    def __init__(self, qubits, num_layers_enc, num_layers_var, 
                 cqca, observables, train, single_param=False,
                 lr_var=0.01, lr_out=0.1):

        self.qubits = qubits
        self.num_qubits = len(qubits)
        self.num_layers_enc = num_layers_enc
        self.num_layers_var = num_layers_var
        self.observables = observables
        self.cqca = cqca # TODO: remove?
        self.train = train # TODO: remove?
        self.single_param = single_param # TODO: remove?

        # cirq.Circuit: The parameterized circuit
        self.circuit = cirq.Circuit() 
        encoding = IQPEncodingCirc(qubits, num_layers_enc)
        self.circuit += encoding.circuit
        variational = PQCACirc(qubits, num_layers_var, cqca, 
                                observables, single_param=single_param)
        self.circuit += variational.circuit

        # int: Number of inputs
        self.num_inputs = encoding.num_inputs

        # The full learning model
        self.model = self._create_model()
        # The models variables
        self.variables = self.model.variables

        self.optimizer_var = tf.keras.optimizers.Adam(learning_rate=lr_var, 
                                                      amsgrad=True)
        self.optimizer_out = tf.keras.optimizers.Adam(learning_rate=lr_out, 
                                                      amsgrad=True)

        self.loss_history = []
        self.val_history = []
        self.test_history = []

    def step(self, X_train, y_train, X_test, y_test, batchsize=None):
        """
        One gradient descent step on the training loss.

        Args:
            X_train (tf.Tensor): Training input.
            y_train (tf.Tensor): Training label.
            X_test (tf.Tensor): Validation input.
            y_test (tf.Tensor): Validation label.
            batchsize (int or None): How the input should be batched. 
                                     Default: None

        Returns:
            loss (np.ndarray): Training loss.
            val_loss (np.ndarray): Validation loss.
        """
        model = self.model

        # Evaluate the labels assigned by the model and the resulting MSE loss
        if batchsize is None:
            X = X_train
            y = y_train
        else:
            indices = np.random.randint(len(y_train), size=batchsize)
            X = tf.gather(X_train, indices)
            y = tf.gather(y_train, indices)
        with tf.GradientTape() as tape:
            tape.watch(model.trainable_variables)
            output = model(X)
            loss = tf.keras.losses.MeanSquaredError()(output, y)

        # Backpropagation
        grads = tape.gradient(loss, model.trainable_variables)

        w_var, w_out = 0, 1
        for optimizer, w in zip([self.optimizer_var, self.optimizer_out], 
                                [w_var, w_out]):
            optimizer.apply_gradients([(grads[w], 
                                        model.trainable_variables[w])
                                        ])

        # Evaluate validation loss on test set
        val_loss = tf.keras.losses.MeanSquaredError()(model(X_test), y_test)

        self.loss_history += [loss.numpy()]
        self.val_history += [val_loss.numpy()]

        return loss.numpy(), val_loss.numpy()
    
    def pickle_model(self, path):
        """
        Pickles the full class keeping learning results and circuit.

        Args:
            path (str): Path to the model save location.
        """
        if self.model != None:
            self.variables = self.model.variables
        # Make pickable
        self.model = None
        self.optimizer_var = None
        self.optimizer_out = None

        pickle.dump([self], open(path, 'wb'))

    def _create_model(self):
        """
        Creates the learning model as tf.keras.Model.

        Returns:
            model (tf.keras.Model): Keras model from PQC.
        """
        input_tensor = tf.keras.Input(shape=(self.num_inputs,), 
                                      dtype=tf.dtypes.float32, name='input')

        # call layer
        pqca_layer = PQCALayer(self.qubits, self.num_layers_enc, 
                               self.num_layers_var, self.cqca, self.observables, 
                               self.train, single_param=self.single_param
                               )([input_tensor])

        if self.train:
            pqca_layer = RescalingLayer(1)(pqca_layer)

        model = tf.keras.Model(inputs=[input_tensor], outputs=pqca_layer)

        return model

class PQCALayer(tf.keras.layers.Layer):
    """
    Praramterized MBQC Ansatz based on Clifford Quantum Cellular Automaton 
    (CQCA) as tensorflow quantum computational layer. 

    Args:
        qubits (cirq.Qubit): The logical qubits.
        num_layers_enc (int): The number of encoding layers.
        num_layers_var(int); The number of variational layers.
        cqca (list of list): List of list of strings of 'CZx', 'H', 'S', 
                                which make up the translationally invariant 
                                cqcas, where x is the distance of the CZ.
        observables (list of cirq.ops): The measured observables.
        train (bool): Whether the tfq layer is trainable or not.
        single_param (bool): Whether or not there is only one variational param
                             per layer. Default: False
    """
    def __init__(self, qubits, num_layers_enc, num_layers_var, 
                 cqca, observables, train, single_param=False,
                 name="PQCA_layer"):
        super(PQCALayer, self).__init__(name=name)

        self.num_layers_enc = num_layers_enc
        self.num_layers_var = num_layers_var
        # self.observables = observables # remove attr

        # define circuit
        circuit = cirq.Circuit()
        encoding = IQPEncodingCirc(qubits, num_layers_enc)
        circuit += encoding.circuit
        variational = PQCACirc(qubits, num_layers_var, cqca, 
                                observables, single_param=single_param)
        circuit += variational.circuit

        # initialize variational params
        if train:
            theta_init = tf.random_normal_initializer(mean=0.0, stddev=0.05)
        else:
            theta_init = tf.random_uniform_initializer(minval=0.0, maxval=np.pi)
        theta_sym = list(variational.params.flat)
        self.theta = tf.Variable(
			initial_value=theta_init(shape=(1, len(theta_sym)), 
            dtype="float32"), trainable=train, name="thetas"
		)
        
        # initialize encoding params
        inputs_single_sym = list(encoding.inputs_single)
        inputs_prod_sym = list(encoding.inputs_prod)

		# Define explicit symbol order. TODO: improve
        symbols = [str(symb) for symb in theta_sym + \
                   inputs_single_sym + \
                   inputs_prod_sym]
        self.indices = tf.constant([symbols.index(a) for a in sorted(symbols)])

        # define computational layers and inputs
        self.empty_circuit = tfq.convert_to_tensor([cirq.Circuit()])
        self.computation_layer = tfq.layers.ControlledPQC(circuit, 
                                                          observables)
        
    def call(self, inputs):
        """
        Tensorflow Quantum way of running the computational layer.

        Args:
            inputs (tf.Tensor): The batched input.

        Returns:
            layer (tf.keras.Model): The tfq model.
        """
        batch_dim = tf.gather(tf.shape(inputs[0]), 0)
        tiled_up_circuits = tf.repeat(self.empty_circuit, repeats=batch_dim)
        tiled_up_thetas = tf.tile(self.theta, multiples=[batch_dim, 1])
        tiled_up_inputs = tf.tile(inputs[0], 
                                    multiples=[1, self.num_layers_enc])

        joined_vars = tf.concat([tiled_up_thetas, tiled_up_inputs], axis=1)
        joined_vars = tf.gather(joined_vars, self.indices, axis=1)

        return self.computation_layer([tiled_up_circuits, joined_vars])

class RescalingLayer(tf.keras.layers.Layer):
    """
    A post-processing layer to rescale the model's expectation values with a 
    trainable weight.

    Args:
        input_dim (int): The dimension of the input.
    """
    def __init__(self, input_dim):
        super(RescalingLayer, self).__init__()
        self.input_dim = input_dim
        self.w = tf.Variable(
            initial_value=tf.ones(shape=(1,input_dim)), dtype="float32",
            trainable=True, name="obs-weights")

    def call(self, inputs):
        """
        Weighting the input by the weight.

        Args:
            inputs (tf.Tensor): The input.

        Returns:
            output (tf.Tensor): The weighted input.
        """
        return tf.math.multiply(inputs, tf.repeat(self.w, 
                                                  repeats=tf.shape(inputs)[0], 
                                                  axis=0)
                                                  )

class IQPEncodingCirc():
    """
    IQP-type encoding circuit based on Havlicek et al.

    Args:
        qubits (cirq.Qubit): The logical qubits.
        num_layers (int): The number of encoding layers.
    """
    def __init__(self, qubits, num_layers):
        self.qubits = qubits
        self.num_qubits = len(qubits)
        self.num_layers = num_layers
        self.num_inputs = self.num_qubits * (self.num_qubits + 1) // 2
        self.inputs_single = sympy.symbols(f'x(0:{self.num_qubits})')
        self.inputs_prod = sympy.symbols(
                        f'y(0:{self.num_qubits * (self.num_qubits - 1) // 2})'
                        )
        self.circuit = self.create_circuit()

    def create_circuit(self):
        """
        Returns the encoding circuit as defined by Havlicek et al.

        Returns:
            circuit (cirq.Circuit): The encoding circuit.
        """
        circuit = cirq.Circuit()

        for l in range(self.num_layers):
            # single qubit layers
            circuit += cirq.Circuit(cirq.H(q) for q in self.qubits)

            circuit += cirq.Circuit(cirq.ZPowGate(
                                    exponent=self.inputs_single[i]
                                    )(q) for i, q in enumerate(self.qubits))
            # entangling layers
            count = 0
            for i in range(self.num_qubits):
                for j in range(i + 1, self.num_qubits):
                    circuit += cirq.Circuit(
                        cirq.ops.ZZPowGate(
                            exponent=self.inputs_prod[count]
                            )(self.qubits[i], self.qubits[j])
                            )
                    count += 1

        return circuit

class PQCACirc():
    """
    Parameterized MBQC Ansatz based on Clifford Quantum Cellular 
    Automata (CQCAs).

    The input cqca specifies the sequential layers of translational invariant 
    Clifford circuits which describe the CQCAs. 
    For example, `[["CZ1", "H"], ["H"]]` describes a circuit with one layer 
    of parameterized Z-rotations followed by nearest-neighbor CZs and Hadamards.
    Then another layer of parameterized Z-rotations followed by Hadamards.
    Then, repeat until there are `num_layers` layers.

    Args:
        qubits (cirq.Qubit): The logical qubits.
        num_layers (int): The number of variational layers.
        cqca (list of list): List of list of strings of 'CZx', 'H', 'S', 
                                which make up the translationally invariant 
                                cqcas, where x is the distance of the CZ.
        observables (list of cirq.ops): The measured observables.
        single_param (bool): Whether or not there is only one variational param
                             per layer. Default: False
    """
    def __init__(self, qubits, num_layers, cqca, observables, 
                 single_param = False):
        self.qubits = qubits
        self.num_qubits = len(qubits)
        self.num_layers = num_layers
        self.observables = observables

        # variational parameters
        if not single_param:
            params = sympy.symbols(f'theta(0:{num_layers * self.num_qubits})')
            self.params = np.asarray(params).reshape(
                            (num_layers, self.num_qubits)
                            )
        else:
            params = sympy.symbols(f'theta(0:{num_layers})')
            self.params = np.asarray(params).reshape((num_layers, 1))
        
        # variational circuit
        self.circuit = self.create_circuit(cqca, single_param=single_param)

    def create_circuit(self, cqca, single_param=False):
        """
        Args:
            cqca (list of list): List of list of strings of 'CZx', 'H', 'S', 
                                 which make up the translationally invariant 
                                 cqcas, where x is the distance of the CZ.
            single_param (bool): Whether or not there is only one variational 
                                 param per layer. Default: False
        """
        # Define circuit
        circuit = cirq.Circuit()

        for l in range(self.num_layers):
            if not single_param:
                circuit += cirq.Circuit(cirq.rz(self.params[l, i])(q) \
                                        for i, q in enumerate(self.qubits)
                                        )
            else: 
                circuit += cirq.Circuit(cirq.rz(self.params[l, 0])(
                                                    self.qubits[0]
                                                    ))
            circuit += self.cqca_layer(cqca[l%len(cqca)])
        
        return circuit

    def cqca_layer(self, cqca):
        """
        Create a CQCA-layer from circuit elements which are Hadamards, S-gates 
        and CZ-gates.

        Args:
            cqca

        Returns:
            circuit (circ.Circuit): The CQCA circuit layer.
        """
        circuit = cirq.Circuit()
        for gate_str in cqca:
            if gate_str == "H":
                circuit += cirq.Circuit(cirq.H(q) for q in self.qubits)
            elif gate_str == "S":
                circuit += cirq.Circuit(cirq.Z(q)**0.5 for q in self.qubits)
            elif gate_str[:2] == "CZ" \
                and int(gate_str[2])>0 \
                and int(gate_str[2])<self.num_qubits:
                    d = int(gate_str[2])
                    circuit += cirq.Circuit(cirq.CZ(
                                self.qubits[i], 
                                self.qubits[(i+d)%self.num_qubits]
                                ) for i in range(self.num_qubits))
            else:
                raise NotImplementedError("We only allow 'H', 'S', 'CZx'")

        return circuit
